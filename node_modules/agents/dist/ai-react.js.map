{"version":3,"sources":["../src/ai-react.tsx"],"sourcesContent":["import { useChat } from \"@ai-sdk/react\";\nimport type { Message } from \"ai\";\nimport type { useAgent } from \"./react\";\nimport { useEffect, use } from \"react\";\nimport type { OutgoingMessage } from \"./ai-types\";\n\ntype GetInitialMessagesOptions = {\n  agent: string;\n  name: string;\n  url: string;\n};\n\n/**\n * Options for the useAgentChat hook\n */\ntype UseAgentChatOptions<State> = Omit<\n  Parameters<typeof useChat>[0] & {\n    /** Agent connection from useAgent */\n    agent: ReturnType<typeof useAgent<State>>;\n    getInitialMessages?:\n      | undefined\n      | null\n      // | (() => Message[])\n      | ((options: GetInitialMessagesOptions) => Promise<Message[]>);\n  },\n  \"fetch\"\n>;\n\n// TODO: clear cache when the agent is unmounted?\nconst requestCache = new Map<string, Promise<Message[]>>();\n\n/**\n * React hook for building AI chat interfaces using an Agent\n * @param options Chat options including the agent connection\n * @returns Chat interface controls and state with added clearHistory method\n */\nexport function useAgentChat<State = unknown>(\n  options: UseAgentChatOptions<State>\n) {\n  const { agent, getInitialMessages, ...rest } = options;\n  const url = `${agent._pkurl\n    .replace(\"ws://\", \"http://\")\n    .replace(\"wss://\", \"https://\")}`;\n\n  async function defaultGetInitialMessagesFetch({\n    url,\n  }: GetInitialMessagesOptions) {\n    const response = await fetch(new Request(`${url}/get-messages`), {\n      headers: options.headers,\n      credentials: options.credentials,\n    });\n    return response.json<Message[]>();\n  }\n\n  const getInitialMessagesFetch =\n    getInitialMessages || defaultGetInitialMessagesFetch;\n\n  function doGetInitialMessages(\n    getInitialMessagesOptions: GetInitialMessagesOptions\n  ) {\n    if (requestCache.has(url)) {\n      return requestCache.get(url)!;\n    }\n    const promise = getInitialMessagesFetch(getInitialMessagesOptions);\n    requestCache.set(url, promise);\n    return promise;\n  }\n\n  const initialMessages =\n    getInitialMessages !== null\n      ? use(\n          doGetInitialMessages({\n            agent: agent.agent,\n            name: agent.name,\n            url,\n          })\n        )\n      : rest.initialMessages;\n\n  useEffect(() => {\n    return () => {\n      requestCache.delete(url);\n    };\n  }, [url]);\n\n  async function aiFetch(\n    request: RequestInfo | URL,\n    options: RequestInit = {}\n  ) {\n    // we're going to use a websocket to do the actual \"fetching\"\n    // but still satisfy the type signature of the fetch function\n    // so we'll return a promise that resolves to a response\n\n    const {\n      method,\n      keepalive,\n      headers,\n      body,\n      redirect,\n      integrity,\n      signal,\n      credentials,\n      mode,\n      referrer,\n      referrerPolicy,\n      window,\n      //  dispatcher, duplex\n    } = options;\n    const id = crypto.randomUUID();\n    const abortController = new AbortController();\n\n    signal?.addEventListener(\"abort\", () => {\n      abortController.abort();\n    });\n\n    agent.addEventListener(\n      \"message\",\n      (event) => {\n        let data: OutgoingMessage;\n        try {\n          data = JSON.parse(event.data) as OutgoingMessage;\n        } catch (error) {\n          // silently ignore invalid messages for now\n          // TODO: log errors with log levels\n          return;\n        }\n        if (data.type === \"cf_agent_use_chat_response\") {\n          if (data.id === id) {\n            controller.enqueue(new TextEncoder().encode(data.body));\n            if (data.done) {\n              controller.close();\n              abortController.abort();\n            }\n          }\n        }\n      },\n      { signal: abortController.signal }\n    );\n\n    let controller: ReadableStreamDefaultController;\n\n    const stream = new ReadableStream({\n      start(c) {\n        controller = c;\n      },\n    });\n\n    agent.send(\n      JSON.stringify({\n        type: \"cf_agent_use_chat_request\",\n        id,\n        url: request.toString(),\n        init: {\n          method,\n          keepalive,\n          headers,\n          body,\n          redirect,\n          integrity,\n          credentials,\n          mode,\n          referrer,\n          referrerPolicy,\n          window,\n          // dispatcher,\n          // duplex\n        },\n      })\n    );\n\n    return new Response(stream);\n  }\n  const useChatHelpers = useChat({\n    initialMessages,\n    sendExtraMessageFields: true,\n    fetch: aiFetch,\n    ...rest,\n  });\n\n  useEffect(() => {\n    function onClearHistory(event: MessageEvent) {\n      if (typeof event.data !== \"string\") {\n        return;\n      }\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (data.type === \"cf_agent_chat_clear\") {\n        useChatHelpers.setMessages([]);\n      }\n    }\n\n    function onMessages(event: MessageEvent) {\n      if (typeof event.data !== \"string\") {\n        return;\n      }\n      let data: OutgoingMessage;\n      try {\n        data = JSON.parse(event.data) as OutgoingMessage;\n      } catch (error) {\n        // silently ignore invalid messages for now\n        // TODO: log errors with log levels\n        return;\n      }\n      if (data.type === \"cf_agent_chat_messages\") {\n        useChatHelpers.setMessages(data.messages);\n      }\n    }\n\n    agent.addEventListener(\"message\", onClearHistory);\n    agent.addEventListener(\"message\", onMessages);\n\n    return () => {\n      agent.removeEventListener(\"message\", onClearHistory);\n      agent.removeEventListener(\"message\", onMessages);\n    };\n  }, [\n    agent.addEventListener,\n    agent.removeEventListener,\n    useChatHelpers.setMessages,\n  ]);\n\n  return {\n    ...useChatHelpers,\n    /**\n     * Set the chat messages and synchronize with the Agent\n     * @param messages New messages to set\n     */\n    setMessages: (messages: Message[]) => {\n      useChatHelpers.setMessages(messages);\n      agent.send(\n        JSON.stringify({\n          type: \"cf_agent_chat_messages\",\n          messages,\n        })\n      );\n    },\n    /**\n     * Clear chat history on both client and Agent\n     */\n    clearHistory: () => {\n      useChatHelpers.setMessages([]);\n      agent.send(\n        JSON.stringify({\n          type: \"cf_agent_chat_clear\",\n        })\n      );\n    },\n  };\n}\n"],"mappings":"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","names":["url","options"]}