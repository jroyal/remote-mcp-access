// src/lib/Proxy.ts
async function Proxy(request, secret, sendRPC) {
  const { pathname } = new URL(request.url);
  const authorization = request.headers.get("Authorization")?.replace(/^Bearer /, "") || "";
  if (authorization !== secret || secret.length !== 64) {
    return new Response("Unauthorized", { status: 401 });
  }
  if (pathname === "/rpc" && request.method === "POST") {
    const { method, args = [] } = await request.json();
    try {
      const result = await sendRPC(method, args);
      if (result instanceof Response) {
        return result;
      } else if (typeof result === "string") {
        return new Response(result);
      } else {
        return Response.json(result);
      }
    } catch (e) {
      return Response.json({
        content: [
          { type: "text", text: e.message },
          { type: "text", text: JSON.stringify(e.stack) }
        ],
        isError: true
      });
    }
  }
  return new Response(null, { status: 404 });
}

// src/modules/ProxyToSelf.ts
var ProxyToSelf = class {
  constructor(worker) {
    this.worker = worker;
    this.env = worker.env;
  }
  env;
  async fetch(request) {
    return Proxy(request, this.env.SHARED_SECRET, (method, args) => {
      const methodReference = this.worker[method];
      if (!methodReference) {
        throw new Error(`WorkerEntrypoint ${this.worker.constructor.name} has no method '${method}'`);
      }
      return this.worker[method].call(this.worker, ...args);
    });
  }
};

// src/modules/MCPEntrypoint.ts
import { DurableObject } from "cloudflare:workers";

// src/lib/sseEdge.ts
import { JSONRPCMessageSchema } from "@modelcontextprotocol/sdk/types.js";
var MAXIMUM_MESSAGE_SIZE = 4 * 1024 * 1024;
var SSEEdgeTransport = class {
  /**
   * Creates a new EdgeSSETransport, which will direct the MPC client to POST messages to messageUrl
   */
  constructor(messageUrl, sessionId) {
    this.messageUrl = messageUrl;
    this.sessionId = sessionId;
    this.stream = new ReadableStream({
      start: (controller) => {
        this.controller = controller;
      },
      cancel: () => {
        this.closed = true;
        this.onclose?.();
      }
    });
  }
  controller = null;
  stream;
  closed = false;
  onclose;
  onerror;
  onmessage;
  async start() {
    if (this.closed) {
      throw new Error("SSE transport already closed! If using Server class, note that connect() calls start() automatically.");
    }
    if (!this.controller) {
      throw new Error("Stream controller not initialized");
    }
    const endpointMessage = `event: endpoint
data: ${encodeURI(this.messageUrl)}?sessionId=${this.sessionId}

`;
    this.controller.enqueue(new TextEncoder().encode(endpointMessage));
  }
  get sseResponse() {
    if (!this.stream) {
      throw new Error("Stream not initialized");
    }
    return new Response(this.stream, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }
    });
  }
  /**
   * Handles incoming Requests
   */
  async handlePostMessage(req) {
    if (this.closed || !this.controller) {
      const message = "SSE connection not established";
      return new Response(message, { status: 500 });
    }
    try {
      const contentType = req.headers.get("content-type") || "";
      if (!contentType.includes("application/json")) {
        throw new Error(`Unsupported content-type: ${contentType}`);
      }
      const contentLength = parseInt(req.headers.get("content-length") || "0", 10);
      if (contentLength > MAXIMUM_MESSAGE_SIZE) {
        throw new Error(`Request body too large: ${contentLength} bytes`);
      }
      const body = await req.json();
      await this.handleMessage(body);
      return new Response("Accepted", { status: 202 });
    } catch (error) {
      this.onerror?.(error);
      return new Response(String(error), { status: 400 });
    }
  }
  /**
   * Handle a client message, regardless of how it arrived. This can be used to inform the server of messages that arrive via a means different than HTTP POST.
   */
  async handleMessage(message) {
    let parsedMessage;
    try {
      parsedMessage = JSONRPCMessageSchema.parse(message);
    } catch (error) {
      this.onerror?.(error);
      throw error;
    }
    this.onmessage?.(parsedMessage);
  }
  async close() {
    if (!this.closed && this.controller) {
      this.controller.close();
      this.stream.cancel();
      this.closed = true;
      this.onclose?.();
    }
  }
  async send(message) {
    if (this.closed || !this.controller) {
      throw new Error("Not connected");
    }
    const messageText = `event: message
data: ${JSON.stringify(message)}

`;
    this.controller.enqueue(new TextEncoder().encode(messageText));
  }
};

// src/modules/MCPEntrypoint.ts
import { Hono } from "hono";
import { cors } from "hono/cors";
var DurableMCP = class extends DurableObject {
  transport;
  props;
  initRun = false;
  async _init(props) {
    this.props = props;
    if (!this.initRun) {
      this.initRun = true;
      await this.init();
    }
  }
  async onSSE(request) {
    this.transport = new SSEEdgeTransport(
      "/sse/message",
      this.ctx.id.toString()
    );
    await this.server.connect(this.transport);
    return this.transport.sseResponse;
  }
  async onMessage(request) {
    return this.transport.handlePostMessage(request);
  }
  static mount(path, {
    binding = "MCP_OBJECT",
    corsOptions
  } = {}) {
    const router = new Hono();
    router.get(path, cors(corsOptions), async (c) => {
      const namespace = c.env[binding];
      const object = namespace.get(namespace.newUniqueId());
      object._init(c.executionCtx.props);
      return await object.onSSE(c.req.raw);
    });
    router.post("/sse/message", cors(corsOptions), async (c) => {
      const namespace = c.env[binding];
      const sessionId = c.req.query("sessionId");
      if (!sessionId) {
        return new Response(
          "Missing sessionId. Expected POST to /sse to initiate new one",
          { status: 400 }
        );
      }
      const object = namespace.get(namespace.idFromString(sessionId));
      return await object.onMessage(c.req.raw);
    });
    return router;
  }
};
export {
  DurableMCP,
  ProxyToSelf
};
